<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="UTF-8">
        <meta name="theme-color content=#0080ff">
        <!--<link rel="manifest" href="manifest.json">-->
        <link rel="icon" href="favicon.ico" type="image/x-icon">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
    </head>

    <body>

<p>v6.1</p>

<button id="readFolder">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€</button>
<button id="selectFolder">èª­ã¿è¾¼ã¿å…ˆ:</button>

<br>
<p id="folderLoad">folderLoad</p>

<p id="clock"></p>

<label for="volumeBar">éŸ³é‡</label>
<input type="range" id="volumeBar" min="0" max="100" step="0.1" value="10">
<input type="number" id="volumeInput" min="0" max="100" step="0.1" value="10">

<label for="muteCheckBox">ãƒŸãƒ¥ãƒ¼ãƒˆã™ã‚‹</label>

<input type="checkbox" id="muteCheckBox" disabled="true">

<p id="volume">volume</p>

<button onclick="settingDialog.showModal()" class="showAfterInput">è¨­å®š</button>

<dialog id="settingDialog">
    <input type="checkbox" id="sceneSelectBool">
    <label for="sceneSelectBool">SceneSelect</label>
    <br>

    <input type="number" min="0" max="12" value="0" id="sceneSelectRange" class="controlableAfterInput">
    <label for="sceneSelectCheckbox">ç¾åœ¨ã®æ™‚åˆ»Â±ã“ã®æ™‚é–“ã®æ›²ãŒæµã‚Œã‚‹</label>
    <br>

    <input type="number" min="0" max="3600" value="60" id="betweenSong" class="controlableAfterInput">
    <label for="betweenSong">æ›²ãŒçµ‚ã‚ã£ã¦ã‹ã‚‰æ¬¡ã®æ›²ãŒå†ç”Ÿã•ã‚Œã‚‹ã¾ã§</label>
    <br>

    <input type="number" min="-12" max="12" value="9" id="timeZone" class="controlableAfterInput">
    <label for="timeZone">ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³(UTC)</label>
    <br>

    <button onclick="saveSetting()">ä¿å­˜</button>
    <br>

    <br>

    <input type="checkbox" id="weatherInternet">
    <label for="weatherInternet">ğŸŒï¸ | å¤©æ°—</label>
    <select id="weatherInput" name="weather">
        <option value="0">None</option>
        <option value="1">Clear</option>
        <option value="2">Clouds</option>
        <option value="3">Rain</option>
        <option value="4">Snow</option>
    </select>
    <br>

    <input type="checkbox" id="speedInternet">
    <label for="speedInternet">ğŸŒï¸ | é€Ÿåº¦</label>
    <input type="int">
    <br>

    <button onclick="settingDialog.close()">close</button>
</dialog>
<br>

<input type="checkbox" id="sceneSelectCheckbox" class="controlableAfterInput">
<label for="sceneSelectCheckbox">SceneSelect</label>
<br>

<input type="checkbox" id="apiCheckbox" class="controlableAfterInput">
<label for="apiCheckbox">ğŸŒï¸</label>
<br>

<button id="startButton">é–‹å§‹</button>

<p id="nowPlaying" style="font-weight: bold;" class="showAfterStarted">nowPlaying</p>

<audio id="audioPlayerM" controls style="display:none;">audioM</audio>
<video id="videoPlayerM" controls width="480" style="display:none;">videoM</video>

<audio id="audioPlayerJ" controls style="display: none;">audioJ</audio>
<video id="videoPlayerJ" controls width="480" style="display: none;">videoJ</video>

<audio id="audioPlayerB" controls style="display:none;">audioB</audio>
<video id="videoPlayerB" controls width="480" style="display:none;">videoB</video>





<button onclick="fileDialog.showModal()" class="showAfterStarted">å‹•ç”»/éŸ³å£°ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¡¨ç¤º</button>

<dialog id="fileDialog">
    <h2 id="nameDialog">title:</h2>
    <p id="coverDialog">cover:</p>
    <p id="originalDialog">original:</p>
    <p id="timeDialog">time:</p>
    <p id="signalDialog">signal:</p>
    <p id="travelDialog">travel:</p>
    <p id="travelOnlyDialog">travelOnly:</p>
    <p id="weatherDialog">weather:</p>
    <p id="duration">duration:</p>
    <p id="source">source:</p>

    <button onclick="fileDialog.close()" class="showAfterStarted">close</button>
</dialog>

    </body>

    <style>

dialog {
    border: none;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}
dialog::backdrop {
    background: rgba(0,0,0,0.5);
}
.showAfterInput {
    display: none;
}
.showAfterStarted {
    display: none;
}
.controlableAfterInput {
    pointer-events: auto;/*é©å½“ãªè¦ç´ ã‚’å…¥ã‚Œãªã„ã¨ã„ã‘ãªã„ã®ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚‚ã®ã‚’å…¥ã‚Œã‚‹*/
}


    </style>

    <script>

const folderInput = document.getElementById("folderInput")//ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å…¥åŠ›ã™ã‚‹ã¨ã“ã‚
const startButton = document.getElementById("startButton")//é–‹å§‹ãƒœã‚¿ãƒ³
const clock = document.getElementById("clock")
const readFolder = document.getElementById("readFolder")
const timezoneInput = document.getElementById("timeZone")

/*ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®Show/Hide/Disabled*/
function hide() {
    document.querySelectorAll(".showAfterInput").forEach(element => {
        element.style.display = "none";
    })
    
    document.querySelectorAll(".showAfterStarted").forEach(element => {
        element.style.display = "none"
    })

    document.querySelectorAll(".controlableAfterInput").forEach(element => {
        element.disabled = true;
    })
}

function showAfterInput() {

    document.querySelectorAll(".showAfterInput").forEach(element => {
        element.style.display = "block";
    })

    document.querySelectorAll(".controlableAfterInput").forEach(element=>{
        element.disabled = false;
    })
}

function showAfterstarted() {
    document.querySelectorAll(".showAfterStarted").forEach(element => {
        element.style.display = "block"
    })
}

startButton.addEventListener("click",showAfterstarted)

document.addEventListener("DOMContentLoaded",function() {
    hide()
})
/**/

/*æ™‚è¨ˆ*/
function newDate() {
    return getTimeInTimezone(Number(timezoneInput.value))
}

function getTimeInTimezone(utcOffset) {
    const now = new Date();
    const utcTime = now.getTime() + (now.getTimezoneOffset() * 60000);
    const targetTime = new Date(utcTime + (3600000 * utcOffset));
    return targetTime;
}

function updateClock() {
    let time = newDate()
    let days = ["æ—¥","æœˆ","ç«","æ°´","æœ¨","é‡‘","åœŸ"]
    let year = time.getFullYear()
    let month = time.getMonth()+1
    let date = time.getDate()
    let day = days[time.getDay()]
    let hour = time.getHours()
    let minute = time.getMinutes()
    let second = time.getSeconds()
    let mSecond = time.getMilliseconds()
    let utcString = String(timezoneInput.value)
    if (0<utcString) {utcString = "+"+utcString}
    clock.innerHTML = `${year}å¹´ ${month}æœˆ ${date}æ—¥ï¼ˆ${day}ï¼‰ ${hour}:${minute}:${second}:${mSecond} UTC${utcString}`
}

document.addEventListener("DOMContentLoaded",function() {
    const id = setInterval(() => {updateClock()},1000)
})
/**/

/*ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿*/
document.addEventListener("DOMContentLoaded",async function() {/*ãƒšãƒ¼ã‚¸ã‚’é–‹ã„ãŸã¨ãã«èª­ã¿è¾¼ã¿ãƒœã‚¿ãƒ³ã«ãƒ‘ã‚¹ã‚’è¡¨ç¤ºã™ã‚‹*/
    const InputFolderPathDB = new DB("MusicPlayerDB_61",1,"InputFolderPath","path")
    InputFolderPathDB.open()
    const data = await InputFolderPathDB.get("folderHandle")
    document.getElementById("selectFolder").innerText = data.name || "ãƒ•ã‚©ãƒ«ãƒ€ã‚’é¸æŠ"
})

document.getElementById("selectFolder").addEventListener("click",async function() {/*èª­ã¿è¾¼ã¿ã™ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚’è¨­å®š*/
    try {
        const dirHandle = await window.showDirectoryPicker()

        const InputFolderPathDB = new DB("MusicPlayerDB_61",1,"InputFolderPath","path")
        await InputFolderPathDB.save({
            path: "folderHandle",
            handle: dirHandle,
            name: dirHandle.name,
        })

        document.getElementById("selectFolder").innerText = dirHandle.name

        showAfterInput()
    } catch (e) {
        console.log(`ã‚¨ãƒ©ãƒ¼:${e}`)
    }
})

readFolder.addEventListener("click",async function() {/*ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã¿ãƒœã‚¿ãƒ³ãŒæŠ¼ã•ã‚ŒãŸã¨ã*/
    try {
        const InputFolderPathDB = new DB("MusicPlayerDB_61",1,"InputFolderPath","path")
        InputFolderPathDB.open()
        const data = await InputFolderPathDB.get("folderHandle")

        if (data && data.handle) {
            const permission = await data.handle.queryPermission({mode: "read" })

            if (permission === "granted" || await data.handle.requestPermission({mode: "read" }) === "granted") {
                const files = await getAllFiles(data.handle);
                globals.save("files",files)
                const scatics = new Statics(files).load()
                load(files)
                document.getElementById("folderLoad").innerText = `èª­ã¿è¾¼ã¿å®Œäº†:${data.handle.name}`
                showAfterInput()
            }
        }
    } catch (error) {
        alert(`ã‚¨ãƒ©ãƒ¼:${error}\nãƒ•ã‚©ãƒ«ãƒ€ãŒå­˜åœ¨ã—ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™`)
        console.error(error)
    }

})

async function getAllFiles(dirHandle, path = '') {
    const files = [];
    
    for await (const entry of dirHandle.values()) {
        const newPath = path ? `${path}/${entry.name}` : entry.name;
        
        if (entry.kind === 'file') {
            const file = await entry.getFile();
            Object.defineProperty(file, 'relativePath', {
                value: newPath,
                writable: false
            });
            files.push(file);
        } else if (entry.kind === 'directory') {
            const subFiles = await getAllFiles(entry, newPath);
            files.push(...subFiles);
        }
    }
    
    return files;
}

async function getPathOfInputFolder(filePathDB) {
    try {
        const dirHandle = await window.showDirectoryPicker()

        await filePathDB.saveData("folderHandle",dirHandle)

        document.getElementById("folderLoad").innerText = `èª­ã¿è¾¼ã¿å®Œäº†:${dirHandle.name}`

        showAfterInput()
    } catch (e) {
        console.log(`ã‚¨ãƒ©ãƒ¼:${e}`)
    }
}

function load(files) {
    for (const file of files) {
        if (file.name === "Settings.json") {
            statics.setSettings(file)
        } else if (file.name === "Statics.json") {
            statics.setStatics(file)
        } else {
            music.push(new Music(file))
        }
    }
}
/**/


/*Class DB*/

class DB{
    constructor(dbName, dbVersion, objectStore, keyPath) {
        this.dbName = dbName;
        this.dbVersion = dbVersion;
        this.objectStoreName = objectStore;
        this.keyPath = keyPath;
        this.db = null;
    }

    async open() {
        return new Promise((resolve,reject) => {
            const request = indexedDB.open(this.dbName,this.dbVersion);

            request.onerror = () => {
                reject(new Error("Database failed to open"))
            };

            request.onsuccess = (event) => {
                this.db = event.target.result;
                resolve(this.db);
            };

            request.onupgradeneeded = (event) => {
                const db = event.target.result;

                if (!db.objectStoreNames.contains(this.objectStoreName)) {
                    db.createObjectStore(this.objectStoreName,{keyPath:this.keyPath})
                }
            }
        })
    }

    async save(data) {
        if (!this.db) {
            await this.open();
        }

        return new Promise((resolve,reject) => {
            const transaction = this.db.transaction([this.objectStoreName],"readwrite");
            const store = transaction.objectStore(this.objectStoreName);
            const request = store.put(data);

            request.onsuccess = () => {
                resolve(request.result);
            }

            request.onerror = () => {
                reject(new Error("Failed to save data"))
            };
        });
    }

    async get(key) {
        if (!this.db) {
            await this.open()
        }

        return new Promise((resolve,reject) => {
            const transaction = this.db.transaction([this.objectStoreName],"readonly");
            const store = transaction.objectStore(this.objectStoreName);
            const request = store.get(key);

            request.onsuccess = () => {
                resolve(request.result);
            }

            request.onerror = () => {
                reject(new Error("Failed to get data"));
            }
        })
    }



    
}
/**/

/*Class Statics*/
class Statics {
    constructor(files) {
        this.files = files
        this.staticsJson = this.files.find(file => file.name === "Statics.json")
        this.settingsJson = this.files.find(file => file.name === "Settings.json")
        console.log(this.staticsJson,this.settingsJson)
    }

    setStatics(json) {
        this.staticsJson = json
    }

    setSettings(json) {
        this.settingsJson = json
    }

    async load() {
        const staticText = await this.staticsJson.text()
        const settingText = await this.settingsJson.text()
        this.statics = JSON.parse(staticText)
        this.settings = JSON.parse(settingText)


    }
}
/**/

/*Class Globals - ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã‚’ä»£ã‚ã‚Šã«ä¿å­˜ã™ã‚‹ã‚¯ãƒ©ã‚¹*/
class Globals {
    constructor() {
        this.data = []
    }

    save(key,data) {
        this.data.push({"key":key,"data":data})
    }

    get(key) {
        return this.data.find(data => data.key === key).data
    }
}

class Music {
    constructor(json) {
        this.json = json
        this.type = json.type

        if (this.type === "bgm") {
            this.hour = json.hour
        } else if (this.type = "music") {
            this.path = json.path
            this.name = json.name
            this.cover = json.cover
            this.original = json.original
            this.time = json.time
            this.signal = json.signal
            this.travel = json.travel
            this.travelOnly = json.travelOnly
            this.weather = json.weather
            this.registrated = json.registrated
            this.duration = json.duration
            this.source = json.source
            this.language = json.language
        }
    }

    setPlayed(played) {
        this.played = played
    }

    setFile(file) {
        this.file = file
    }
}

class MusicManager {
    constructor() {
        this.musics = []
    }

    push(music) {
        this.musics.push(music)
    }


}

const globals = new Globals()

const music = new MusicManager()
const statics = new Statics()

function savePathOfIndexFolder() {

}


/*
folderInput.addEventListener("input",async function() {

    showAfterInput()

    event.target.filesã‹ã‚‰files,paths,namesã‚’ä½œã‚‹
    const files = event.target.files

    let temp = []
    for (const data of files) {
        temp.push(data.webkitRelativePath)
    }
    const paths = temp

    temp = []
    paths.forEach(path => {
        temp.push(path.split(/[/\\]/).pop().replace(/\.[^.]+$/,''))
    })
    const names = temp
    


    



})
*/


    </script>
</html>