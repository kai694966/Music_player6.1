<!DOCTYPE html>
<html lang="ja">
    <head>
        <meta charset="UTF-8">
        <meta name="theme-color content=#0080ff">
        <!--<link rel="manifest" href="manifest.json">-->
        <link rel="icon" href="favicon.ico" type="image/x-icon">
        <meta name="viewport" content="width=device-width,initial-scale=1.0">
    </head>

    <body>

<p>v6.1</p>

<button id="readFolder">ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€</button>

<br>
<p id="folderLoad">folderLoad</p>

<p id="clock"></p>

<label for="volumeBar">éŸ³é‡</label>
<input type="range" id="volumeBar" min="0" max="100" step="0.1" value="10">
<input type="number" id="volumeInput" min="0" max="100" step="0.1" value="10">

<label for="muteCheckBox">ãƒŸãƒ¥ãƒ¼ãƒˆã™ã‚‹</label>

<input type="checkbox" id="muteCheckBox" disabled="true">

<p id="volume">volume</p>

<button onclick="settingDialog.showModal()" class="showAfterInput">è¨­å®š</button>

<dialog id="settingDialog">
    <input type="number" min="0" max="12" value="0" id="sceneSelectRange" class="controlableAfterInput">
    <label for="sceneSelectCheckbox">ç¾åœ¨ã®æ™‚åˆ»Â±ã“ã®æ™‚é–“ã®æ›²ãŒæµã‚Œã‚‹</label>
    <br>

    <input type="number" min="0" max="3600" value="60" id="betweenSong" class="controlableAfterInput">
    <label for="betweenSong">æ›²ãŒçµ‚ã‚ã£ã¦ã‹ã‚‰æ¬¡ã®æ›²ãŒå†ç”Ÿã•ã‚Œã‚‹ã¾ã§</label>
    <br>

    <input type="number" min="-12" max="12" value="9" id="timeZone" class="controlableAfterInput">
    <label for="timeZone">ã‚¿ã‚¤ãƒ ã‚¾ãƒ¼ãƒ³(UTC)</label>
    <br>

    <button onclick="saveSetting()">ä¿å­˜</button>
    <button onclick="settingDialog.close()">close</button>
</dialog>
<br>

<input type="checkbox" id="sceneSelectCheckbox" class="controlableAfterInput">
<label for="sceneSelectCheckbox">SceneSelect</label>
<br>

<input type="checkbox" id="apiCheckbox" class="controlableAfterInput">
<label for="apiCheckbox">ğŸŒï¸</label>
<br>

<button id="startButton">é–‹å§‹</button>

<p id="nowPlaying" style="font-weight: bold;" class="showAfterStarted">nowPlaying</p>

<audio id="audioPlayerM" controls style="display:none;">audioM</audio>
<video id="videoPlayerM" controls width="480" style="display:none;">videoM</video>

<audio id="audioPlayerJ" controls style="display: none;">audioJ</audio>
<video id="videoPlayerJ" controls width="480" style="display: none;">videoJ</video>

<audio id="audioPlayerB" controls style="display:none;">audioB</audio>
<video id="videoPlayerB" controls width="480" style="display:none;">videoB</video>





<button onclick="fileDialog.showModal()" class="showAfterStarted">å‹•ç”»/éŸ³å£°ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’è¡¨ç¤º</button>

<dialog id="fileDialog">
    <h2 id="nameDialog">title:</h2>
    <p id="coverDialog">cover:</p>
    <p id="originalDialog">original:</p>
    <p id="timeDialog">time:</p>
    <p id="signalDialog">signal:</p>
    <p id="travelDialog">travel:</p>
    <p id="travelOnlyDialog">travelOnly:</p>
    <p id="weatherDialog">weather:</p>
    <p id="duration">duration:</p>
    <p id="source">source:</p>

    <button onclick="fileDialog.close()" class="showAfterStarted">close</button>
</dialog>

    </body>

    <style>

dialog {
    border: none;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}
dialog::backdrop {
    background: rgba(0,0,0,0.5);
}
.showAfterInput {
    display: none;
}
.showAfterStarted {
    display: none;
}
.controlableAfterInput {
    pointer-events: auto;/*é©å½“ãªè¦ç´ ã‚’å…¥ã‚Œãªã„ã¨ã„ã‘ãªã„ã®ã§ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚‚ã®ã‚’å…¥ã‚Œã‚‹*/
}


    </style>

    <script>

const folderInput = document.getElementById("folderInput")//ãƒ•ã‚¡ã‚¤ãƒ«ã‚’å…¥åŠ›ã™ã‚‹ã¨ã“ã‚
const startButton = document.getElementById("startButton")//é–‹å§‹ãƒœã‚¿ãƒ³
const clock = document.getElementById("clock")
const readFolder = document.getElementById("readFolder")
const timezoneInput = document.getElementById("timeZone")

/*ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®Show/Hide/Disabled*/
function hide() {
    document.querySelectorAll(".showAfterInput").forEach(element => {
        element.style.display = "none";
    })
    
    document.querySelectorAll(".showAfterStarted").forEach(element => {
        element.style.display = "none"
    })

    document.querySelectorAll(".controlableAfterInput").forEach(element => {
        element.disabled = true;
    })
}

function showAfterInput() {

    document.querySelectorAll(".showAfterInput").forEach(element => {
        element.style.display = "block";
    })

    document.querySelectorAll(".controlableAfterInput").forEach(element=>{
        element.disabled = false;
    })
}

function showAfterstarted() {
    document.querySelectorAll(".showAfterStarted").forEach(element => {
        element.style.display = "block"
    })
}

startButton.addEventListener("click",showAfterstarted)

document.addEventListener("DOMContentLoaded",function() {
    hide()
})
/**/

/*æ™‚è¨ˆ*/
function newDate() {
    return getTimeInTimezone(Number(timezoneInput.value))
}

function getTimeInTimezone(utcOffset) {
    const now = new Date();
    const utcTime = now.getTime() + (now.getTimezoneOffset() * 60000);
    const targetTime = new Date(utcTime + (3600000 * utcOffset));
    return targetTime;
}

function updateClock() {
    let time = newDate()
    let days = ["æ—¥","æœˆ","ç«","æ°´","æœ¨","é‡‘","åœŸ"]
    let year = time.getFullYear()
    let month = time.getMonth()+1
    let date = time.getDate()
    let day = days[time.getDay()]
    let hour = time.getHours()
    let minute = time.getMinutes()
    let second = time.getSeconds()
    let mSecond = time.getMilliseconds()
    let utcString = String(timezoneInput.value)
    if (0<utcString) {utcString = "+"+utcString}
    clock.innerHTML = `${year}å¹´ ${month}æœˆ ${date}æ—¥ï¼ˆ${day}ï¼‰ ${hour}:${minute}:${second}:${mSecond} UTC${utcString}`
}

document.addEventListener("DOMContentLoaded",function() {
    const id = setInterval(() => {updateClock()},1000)
})
/**/

/*ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿*/
readFolder.addEventListener("click",async function() {
    const filePathDB = await new DB("MusicPlayerDB_61",1,"InputFolderPath","name").init()
    const path = await filePathDB.getData("filePath")
    if (path === null) {
        await getPathOfInputFolder(filePathDB)
    }
})

async function getPathOfInputFolder(filePathDB) {
    try {
        const dirHandle = await window.showDirectoryPicker()

        await filePathDB.saveData("folderHandle",dirHandle)

        document.getElementById("folderLoad").innerText = `èª­ã¿è¾¼ã¿å®Œäº†:${dirHandle.name}`

        showAfterInput()
    } catch (e) {
        console.log(`ã‚¨ãƒ©ãƒ¼:${e}`)
    }
}
/**/


/*Class DB*/

class DB{
    constructor(dbname,dbversion,objectStore,keyPath) {
        this.dbname = dbname
        this.dbversion = dbversion
        this.objectStore = objectStore
        this.keyPath = keyPath
        this.db = null
    }

    async init() {


        this.db = await this.openDB();
        return this
    }

    openDB() {
        return new Promise((resolve, reject) => {
        const request = indexedDB.open(this.dbname,this.dbversion);/*åå‰ã€ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’æŒ‡å®šã—ã¦DBã«æ¥ç¶š*/
        request.onupgradeneeded = (event) => {/*æ¥ç¶šã—ãŸã¨ãã®åˆæœŸåŒ–ç­‰ã®å‡¦ç†*/
            const db = event.target.result;
            if (!db.objectStoreNames.contains(this.objectStore)) {/*ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¹ãƒˆã‚¢ã«playedã®åå‰ãŒå«ã¾ã‚Œãªã„ã¨ã*/
                db.createObjectStore(this.objectStore, { keyPath: this.keyPath });/*ãƒãƒƒã‚·ãƒ¥ã€keyPath*/
            }
        };
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
        });
    }


    async saveData(name, data) {
        return new Promise((resolve, reject) => {
            const tx = this.db.transaction(this.objectStore, "readwrite");
            const store = tx.objectStore(this.objectStore);
            store.put({ name, data});
            tx.oncomplete = () => resolve();
            tx.onerror = () => reject(tx.error);
        });
    }


    async getData(name) {
        return new Promise((resolve, reject) => {
            const tx = this.db.transaction(this.objectStore, "readonly");
            const store = tx.objectStore(this.objectStore);
            const request = store.get(name);
            request.onsuccess = () => {
                const record = request.result;
                if (record) {
                    resolve(
                        record.data
                    ); // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒæœ‰åŠ¹
                } else {
                    resolve(null); // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãªã— or æ›´æ–°ã•ã‚Œã¦ã„ã‚‹
                }
            };

            request.onerror = () => reject(request.error);
        });
    }
}
/**/

function savePathOfIndexFolder() {

}


/*
folderInput.addEventListener("input",async function() {

    showAfterInput()

    event.target.filesã‹ã‚‰files,paths,namesã‚’ä½œã‚‹
    const files = event.target.files

    let temp = []
    for (const data of files) {
        temp.push(data.webkitRelativePath)
    }
    const paths = temp

    temp = []
    paths.forEach(path => {
        temp.push(path.split(/[/\\]/).pop().replace(/\.[^.]+$/,''))
    })
    const names = temp
    


    



})
*/


    </script>
</html>